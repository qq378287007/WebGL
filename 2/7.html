<html>

<body>
    <!--canvas标签创建一个宽高均为400像素蓝色背景的画布-->
    <canvas id="webgl" width="400" height="400" style="background-color: blue"></canvas>

    <script>
        //通过getElementById()方法获取canvas画布
        var canvas = document.getElementById('webgl');

        //获取上下文-二维
        //var gl = canvas.getContext('2d');
        //获取上下文-三维
        var gl = canvas.getContext('webgl');

        //顶点着色器
        var VSHADER_SOURCE = `
            attribute vec4 a_Position;
            uniform mat4 u_TranslateMatrix;
            void main() {
                gl_Position = u_TranslateMatrix * a_Position;
            }`

        //片元着色器
        var FSHADER_SOURCE = `
            precision mediump float;
            uniform vec4 u_FragColor;
            void main() {
                gl_FragColor = u_FragColor;
            }`

        //初始化着色器函数
        function initShader(gl, VSHADER_SOURCE, FSHADER_SOURCE) {
            //创建顶点着色器对象
            var vertexShader = gl.createShader(gl.VERTEX_SHADER);
            //创建片元着色器对象
            var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            //引入顶点、片元着色器源代码
            gl.shaderSource(vertexShader, VSHADER_SOURCE);
            gl.shaderSource(fragmentShader, FSHADER_SOURCE);
            //编译顶点、片元着色器
            gl.compileShader(vertexShader);
            gl.compileShader(fragmentShader);

            //创建程序对象program
            var program = gl.createProgram();
            //附着顶点着色器和片元着色器到program
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            //链接program
            gl.linkProgram(program);
            //使用program
            gl.useProgram(program);

            gl.program = program;

            //返回程序program对象
            return program;
        }

        function init() {
            //通过getElementById()方法获取canvas画布
            var canvas = document.getElementById('webgl');
            //通过方法getContext()获取WebGL上下文
            var gl = canvas.getContext('webgl');
            //初始化着色器
            initShader(gl, VSHADER_SOURCE, FSHADER_SOURCE);

            // 设置canvas的背景色
            gl.clearColor(0.0, 0.0, 0.0, 1.0);

            //清空canvas
            gl.clear(gl.COLOR_BUFFER_BIT);

            //给片元着色器uniform变量u_FragColor赋值
            setFragColor(gl)

            //初始化顶点
            var n = initVertexBuffers(gl)

            //获取顶点着色器uniform变量u_TranslateMatrix(平移矩阵)的存储地址
            var u_TranslateMatrix = gl.getUniformLocation(gl.program, 'u_TranslateMatrix')

            //在 x、y、z轴方向上平移的距离
            var Tx = 0.5
            var Ty = 0.5
            var Tz = 0.0

            //创建平移矩阵的类型化数组
            var translateMatrix = new Float32Array([
                1.0, 0.0, 0.0, 0.0,
                0.0, 1.0, 0.0, 0.0,
                0.0, 0.0, 1.0, 0.0,
                Tx, Ty, Tz, 1.0
            ])

            //向顶点着色器uniform变量u_TranslateMatrix传值
            gl.uniformMatrix4fv(u_TranslateMatrix, false, translateMatrix)

            //绘制三角形
            gl.drawArrays(gl.TRIANGLES, 0, n)
        }

        //给片元着色器uniform变量u_FragColor赋值
        function setFragColor(gl) {
            //获取片元着色器uniform变量u_FragColor的存储地址
            var u_FragColor = gl.getUniformLocation(gl.program, 'u_FragColor');
            //向片元着色器uniform变量u_FragColor传值
            gl.uniform4f(u_FragColor, 0.0, 1.0, 0.0, 1.0) //绿色
        }

        //初始化顶点
        function initVertexBuffers(gl) {
            var vertices = new Float32Array([
                0.0, 0.5,
                -0.5, -0.5,
                0.5, -0.5
            ])

            //1.创建缓冲区对象
            var vertexBuffer = gl.createBuffer();
            if (!vertexBuffer) {
                console.log('创建缓冲区对象失败！')
                return -1
            }
            //gl.deleteBuffer(buffer)，删除缓冲区对象

            //2.将缓冲区对象绑定到目标
            //gl.ARRAY_BUFFER			表示缓冲区对象中包含了顶点的数据
            //gl.ELEMENT_ARRAY_BUFFER	表示缓冲区对象中包含了顶点的索引值 
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer)

            //3.向缓冲区对象中写入数据
            //gl.STATIC_DRAW		只会向缓冲区对象中写入一次数据，但需要绘制很多次
            //gl.STREAM_DRAW		只会向缓冲区对象中写入一次数据，然后绘制若干次
            //gl.DYNAMIC_DRAW		会向缓冲区对象中多次写入数据，并绘制很多次
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW)

            var a_Position = gl.getAttribLocation(gl.program, 'a_Position'); //获取着色器attribute变量a_Position的存储地址

            //4.将缓冲区对象分配给a_Position变量
            //顶点的分量个数为2
            //true或false，表明是否非浮点型的数据归一化到[0,1]或[-1,1]区间
            //stride    指定相邻两个顶点间的字节数，默认为0
            //offset	指定缓冲区对象中的偏移量（以字节为单位），即attribute变量从缓冲区的何处开始存储，0代表起始位置
            gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 0, 0)

            //5.连接a_Position变量与分配给它的缓冲区对象
            gl.enableVertexAttribArray(a_Position)
            //关闭分配，gl.deleteBuffer(location)

            return vertices.length / 2

        }

        init()

    </script>
</body>


</html>
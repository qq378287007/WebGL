<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>OBJ Viewer</title>
</head>

<body>
  <canvas id="cvs" width="800" height="600">
    Please use a browser that supports "canvas"
  </canvas>
  <script src="initShaders.js"></script>
  <script src="writeGLData.js"></script>
  <script src="matrix.js"></script>
  <script src="initBuffers.js"></script>
  <script src="OBJParser.js"></script>
  <script>
    // Vertex shader program
    var VSHADER_SOURCE = `
    attribute vec4 a_Position;
    attribute vec4 a_Color;
    attribute vec4 a_Normal;
    uniform mat4 u_MvpMatrix;
    uniform mat4 u_NormalMatrix;
    varying vec4 v_Color;
    void main(){
      vec3 lightDirection = vec3(-0.35, 0.35, 0.87);
      gl_Position =  u_MvpMatrix * a_Position;
      vec3 normal = normalize(vec3(u_NormalMatrix * a_Normal));
      float nDotL = max(dot(normal, lightDirection), 0.0);
      v_Color = vec4(a_Color.rgb * nDotL, a_Color.a);
    }`;
    // Fragment shader program
    var FSHADER_SOURCE = `
    #ifdef GL_ES
      precision mediump float;
    #endif
    varying vec4 v_Color;
    void main() {
      gl_FragColor = v_Color;
    }`;

    const canvas = document.getElementById('cvs');
    const gl = canvas.getContext('webgl');
    initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE);
    gl.clearColor(0.2, 0.2, 0.2, 1.0);
    gl.enable(gl.DEPTH_TEST);

    // Start reading the OBJ file
    //readOBJFile('cube.obj', gl, 40, true);
    //readOBJFile('house_obj.obj', gl, 60, true);
    readOBJFile('teamugobj.obj', gl, 60, true);
    //readOBJFile('medieval house.obj', gl, 15, true);
    //readOBJFile('farmhouse_obj.obj', gl, 5, true);
    //readOBJFile('Old House 2 3D Models.obj', gl, 5, true);

    const ANGLE_STEP = 30;   // The increments of rotation angle (degrees)
    var last = Date.now(); // Last time that this function was called
    function animate(angle) {
      const now = Date.now();   // Calculate the elapsed time
      const elapsed = now - last;
      last = now;
      // Update the current rotation angle (adjusted by the elapsed time)
      const newAngle = angle + (ANGLE_STEP * elapsed) / 1000.0;
      return newAngle;
    }

    var currentAngle = 0.0; // Current rotation angle [degree]
    function tick() {   // Start drawing
      currentAngle = animate(currentAngle); // Update current rotation angle
      draw(gl);
      requestAnimationFrame(tick, canvas);
    };
    tick();

    // Read a file
    function readOBJFile(fileName, gl, scale, reverse) {
      const request = new XMLHttpRequest();

      request.onreadystatechange = function () {
        if (request.readyState === 4 && request.status !== 404) {
          onReadOBJFile(request.responseText, fileName, gl, scale, reverse);
        }
      }
      request.open('GET', fileName, true); // Create a request to acquire the file
      request.send();                      // Send the request
    }

    var g_objDoc = null;      // The information of OBJ file
    var g_drawingInfo = null; // The information for drawing 3D model

    // OBJ File has been read
    function onReadOBJFile(fileString, fileName, gl, scale, reverse) {
      const objDoc = new OBJDoc(fileName);  // Create a OBJDoc object
      const result = objDoc.parse(fileString, scale, reverse); // Parse the file
      if (!result) {
        g_objDoc = null;
        g_drawingInfo = null;
        console.log("OBJ file parsing error.");
        return;
      }
      g_objDoc = objDoc;
    }

    const viewProjMatrix = new Matrix4();
    viewProjMatrix.setPerspective(30.0, canvas.width / canvas.height, 1.0, 5000.0);
    viewProjMatrix.lookAt(0.0, 500.0, 200.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);
    function draw(gl) {
      if (g_objDoc != null && g_objDoc.isMTLComplete()) { // OBJ and all MTLs are available
        g_drawingInfo = onReadComplete(gl, g_objDoc);
        g_objDoc = null;
      }
      if (!g_drawingInfo)
        return;   // モデルを読み込み済みか判定

      const g_modelMatrix = new Matrix4();
      g_modelMatrix.setRotate(currentAngle, 1.0, 0.0, 0.0); // 適当に回転
      g_modelMatrix.rotate(currentAngle, 0.0, 1.0, 0.0);
      g_modelMatrix.rotate(currentAngle, 0.0, 0.0, 1.0);

      // Calculate the normal transformation matrix and pass it to u_NormalMatrix
      const g_normalMatrix = new Matrix4();
      g_normalMatrix.setInverseOf(g_modelMatrix);
      g_normalMatrix.transpose();
      writeUniformMatrix4fv(gl, 'u_NormalMatrix', g_normalMatrix.elements);

      // Calculate the model view project matrix and pass it to u_MvpMatrix
      const g_mvpMatrix = new Matrix4();
      g_mvpMatrix.set(viewProjMatrix);
      g_mvpMatrix.multiply(g_modelMatrix);
      writeUniformMatrix4fv(gl, 'u_MvpMatrix', g_mvpMatrix.elements);

      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      gl.drawElements(gl.TRIANGLES, g_drawingInfo.indices.length, gl.UNSIGNED_SHORT, 0);
    }

    // OBJ File has been read compreatly
    function onReadComplete(gl, objDoc) {
      // Acquire the vertex coordinates and colors from OBJ file
      const drawingInfo = objDoc.getDrawingInfo();

      // Write data into the buffer object
      initArrayBuffer(gl, drawingInfo.vertices, 'a_Position', 3);
      initArrayBuffer(gl, drawingInfo.normals, 'a_Normal', 3);
      initArrayBuffer(gl, drawingInfo.colors, 'a_Color', 4);

      // Write the indices to the buffer object
      initElementBuffer(gl, drawingInfo.indices);

      return drawingInfo;
    }
  </script>
</body>

</html>